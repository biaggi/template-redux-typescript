// not really necessary, but splits logics

import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { RootState } from "../../app/store";
import { getRepositories } from "./githubApi";
import { Repo } from "./githubTypes";

export interface GithubReposState {
  status: "idle" | "loading" | "failed";
  repos?: Repo[];
}

export const initialState: GithubReposState = {
  status: "idle",
};

export const getRepositoriesAsync = createAsyncThunk<
  Repo[],
  void,
  { state: RootState }
>("githubRepos/getRepositories", async (params, thunkApi) => {
  const state = thunkApi.getState();
  const accessToken = state?.github?.accessToken?.access_token;
  if (accessToken) {
    const result = await getRepositories(accessToken);
    return result;
  }

  thunkApi.rejectWithValue("");
});

export const githubReposSlice = createSlice({
  name: "repos",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      /**
       * Getting a repository list
       */
      .addCase(getRepositoriesAsync.pending, (state) => {
        return {...state, status: 'loading'}
      })
      .addCase(getRepositoriesAsync.fulfilled, (state, action) => {
        return {...state, status: 'idle', repos: action.payload}
      })
      .addCase(getRepositoriesAsync.rejected, (state) => {
        return {...state, status: 'failed'}
      });
  },
});

export const selectGithubRepositories = (state: RootState): GithubReposState =>
  state.repos;

export default githubReposSlice.reducer;
